created: 20251216020848447
description: 伪选择器中伪类与伪元素的区别，其中，伪类用于选择具有某种状态、位置的元素，而伪元素则用于选择元素的一部分，或者生成虚拟内容。
modified: 20251220153327046
modifier: uzvg
progress: Completed
rating: Valuable
source: CSS选择器/伪选择器
tags: PermanentNotes CSS Selector
title: 伪类与伪元素的区别
type: text/vnd.tiddlywiki
visibility: Public

!! 结论：

* 伪类 = 选择具有某种状态或条件的“已有元素”
* 伪元素 = 选择“元素的一部分”，并且可以“生成”虚拟内容


!! 辨析：

* 伪类不会创建任何新东西
* 伪元素可以“像新节点一样”参与渲染

; 为什么说伪类「仍然只是选择元素」
* 伪类做的事情，本质是在现有 DOM 元素集合中，加一个条件过滤器

; 伪元素为什么“本质上不一样”？
* 因为中它参与了浏览器的渲染树（render tree），但不在 DOM 树中，以 `::before` 为例：

```css
button::before {
  content: "★";
}
```

这意味着页面上''真的多了一个可见的东西''，它可以有尺寸，有颜色，有定位，有动画，但在 HTML 里''找不到它''，这已经不是“选择谁”的问题了，而是“在这个元素的渲染结构中，多出一个部分”。

!! 一个非常有用的判断标准

* 伪类在不写`content`的时候也有意义
* 伪元素在不写`content`时，大多数时候没意义

!!! 例如：

```css
# 伪类，有意义✅
a:hover { color: red; }
```

```css
# 伪元素（大多数）：❌ 没意义
a::before { color: red; }  /* 什么都不会出现 */
```

👉 这说明：

* 伪类 ≠ 内容
* 伪元素 ≈ 内容结构

⚠️ 注意：`::first-line` / `::selection` 是特例，它们不是生成新内容，而是“切片已有内容”）

!! 实践总结：

* 伪类解决的是`什么时候 / 哪个元素`的问题
* 伪元素解决的是`这个元素看起来由哪几部分组成`的问题
* 能用伪元素做的装饰，尽量别加真实 DOM 节点。比如：图标、分隔线、hover 提示、状态小点等。用 `::before / ::after`，结构会干净很多。

<<remembercz "20251216030707022"
	"伪类选择的是具有{某种状态或条件}的{已有元素}。">>

<<remembercz "20251216030507524"
	"{伪元素}选择的是{元素的一部分}，并且可以{生成虚拟内容}">>

<<remembercz "20251216030901325"
	"伪类{不会}创建新东西。">>

<<remembercz "20251216030945825"
	"伪元素{能够}像新节点一样参与渲染。">>

<<rememberq "20251216015457323"
	"伪选择器中的`伪类`可以为元素生成内容吗？"
	"不能。">>

<<rememberq "20251216015908456"
	"`伪元素`跟`伪类`的最主要区别？"
	"伪元素用于生成内容，而伪类仍用于选择。">>

<<rememberq "20251220153135895"
	"为什么说伪类仍然只是选择元素？"
	"因为伪类做的事情，本质是在现有 DOM 元素集合中，加一个条件过滤器">>

<<rememberq "20251216031048736"
	"为什么说伪元素本质上与伪类不一样？"
	"""因为它虽然参与了浏览器的渲染树（render tree），但不在 DOM 树中""">>

<<remembercz "20251216031212193"
	"{伪元素}在不写`content`的时候，一般没有意义。">>

<<remembercz "20251216031352000"
	"在工作中，{伪类}解决的是{什么时候}、{哪个元素}的问题。">>

<<remembercz "20251216031847895"
	"能用{伪元素}做的装饰，尽量{别加真实 DOM 节点。比如：图标、分隔线、hover 提示、状态小点等。用 `::before / ::after`，结构会干净很多}。">>