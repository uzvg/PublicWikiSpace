created: 20250702090611555
modified: 20250702094908562
progress: Pending
rating: Plain
tags: PermanentNotes zsh
title: zsh Shell通配符模式
type: text/vnd.tiddlywiki
visibility: Public

当然！这里给你一份''简明扼要的 Shell 通配符（globbing pattern）总结''：

# 🌟 zsh Shell 通配符模式（Globbing Pattern）一览

✅ ''用途：''

* 用来匹配字符串（在文件名匹配和参数扩展中都一样）

!! 🚀 基本通配符

| 通配符                 | 含义                     | 举例                                         |
| `*`                 | 匹配''任意长度''（包括零长度）的任意字符 | `*.txt` 匹配 `foo.txt`, `bar.txt`            |
| `?`                 | 匹配''任意单个字符''           | `file?.log` 匹配 `file1.log`, `fileA.log`    |
| `[abc]`             | 匹配 ''a、b 或 c 中任一个字符''  | `file[12].txt` 匹配 `file1.txt`, `file2.txt` |
| `[!abc]` 或 `[^abc]` | 匹配 ''除a、b、c之外的任意一个字符'' | `file[!3].txt` 不匹配 `file3.txt`             |

!! 🚀 扩展通配符（zsh专有，需启用）

（如果使用 `setopt EXTENDED_GLOB`）

| 通配符    | 含义         |
| ------ | ---------- |
| `(#i)` | 不区分大小写匹配   |
| `(#b)` | 支持“回溯引用”匹配 |

（这些高级特性在参数扩展里较少用）

!! 🚀 特殊模式（目录匹配）

| 通配符   | 含义                               |
| ----- | -------------------------------- |
| `''`  | 递归匹配任意层级子目录（需 `setopt GLOBSTAR`） |
| `''/` | 匹配所有子目录路径                        |

!! 🚀 小技巧

* 通配符里的 `*` 并不需要写成 `.*`，直接写 `*` 就表示“任意字符，任意长度”。
* 如果在参数扩展里使用：

** `${var#pattern}`：去掉''前缀''
** `${var%pattern}`：去掉''后缀''
** 所用的`pattern`就是这些通配符模式。

!! 🚀 示例对照

| 模式               | 匹配                                |
| ---------------- | --------------------------------- |
| `*`              | 任意字符串                             |
| `foo*`           | 以`foo`开头的字符串                      |
| `*.log`          | 以`.log`结尾的字符串                     |
| `*bar*`          | 中间包含`bar`                         |
| `file?.txt`      | `file1.txt`, `fileA.txt`等，正好多一个字符 |
| `file[0-9].txt`  | `file0.txt`到`file9.txt`           |
| `file[!0-9].txt` | 不以数字结尾的文件                         |

✅ ''与正则表达式的区别''

* ''不是正则''：不能用 `+`, `|`, `()`, `{}`等正则符号。
* 只支持基本的 `*`, `?`, `[]`。

如果你想，我可以再帮你列出：

* ''更多高级 globbing 示例''
* ''与正则的对照表''
* ''实际应用（如批量重命名、参数扩展）''

随时告诉我！
